<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Public BNG Register</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Minimal styling -->
  <link href="https://unpkg.com/sakura.css/css/sakura.css" rel="stylesheet" type="text/css">
  <!-- Chart.js for charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- PapaParse for CSV; SheetJS for XLSX (optional) -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    .row { display:flex; gap:1rem; flex-wrap:wrap; }
    .card { border:1px solid #e5e5e5; padding:1rem; border-radius:8px; flex:1; min-width:240px;}
    canvas { max-width:100%; }
    .warn { background:#fff3cd; padding:0.5rem 0.75rem; border-radius:6px; }
    .ok { background:#e8f5e9; padding:0.5rem 0.75rem; border-radius:6px; }
    table { width:100%; overflow:auto; display:block; }
    th, td { white-space:nowrap; }
    .controls { display:flex; gap:.5rem; flex-wrap:wrap; align-items:center; }
    input[type=text]{ width:100%; max-width:520px; }
  </style>
</head>
<body>
  <h1>Public BNG Register</h1>
  <p>Loads two datasets (consolidated + long), cross-checks them, and shows summaries and habitat breakdowns.</p>

  <div class="controls">
    <label>Consolidated CSV/XLSX URL:
      <input id="conUrl" type="text" placeholder="https://.../consolidated.csv">
    </label>
    <label>Long CSV/XLSX URL:
      <input id="longUrl" type="text" placeholder="https://.../long.csv">
    </label>
    <button id="loadBtn">Load</button>
  </div>

  <p>Or upload files locally (privacy-friendly; stays in browser):</p>
  <div class="controls">
    <input id="conFile" type="file" accept=".csv,.xlsx,.xls">
    <input id="longFile" type="file" accept=".csv,.xlsx,.xls">
    <button id="uploadBtn">Use Uploaded Files</button>
  </div>

  <div id="status"></div>

  <div class="row">
    <div class="card">
      <h3>Snapshot</h3>
      <div id="snapshot"></div>
    </div>
    <div class="card">
      <h3>Cross-check</h3>
      <div id="crosscheck"></div>
    </div>
    <div class="card">
      <h3>Totals</h3>
      <div id="totals"></div>
    </div>
  </div>

  <h3>Habitat breakdown (from long file)</h3>
  <canvas id="habitatChart" height="140"></canvas>

  <h3>Sites (from consolidated file)</h3>
  <div class="controls">
    <input id="siteFilter" type="text" placeholder="Filter by site name, LPA, developer, region..." />
  </div>
  <table id="sitesTable">
    <thead><tr id="sitesHead"></tr></thead>
    <tbody id="sitesBody"></tbody>
  </table>

<script>
const statusEl = document.getElementById('status');
const crossEl = document.getElementById('crosscheck');
const snapEl = document.getElementById('snapshot');
const totalsEl = document.getElementById('totals');
const sitesHead = document.getElementById('sitesHead');
const sitesBody = document.getElementById('sitesBody');
const siteFilter = document.getElementById('siteFilter');

let consolidated = [];
let longrows = [];
let habitatChart;

function readCSVFromURL(url){
  return new Promise((resolve, reject)=>{
    Papa.parse(url, {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: res => resolve(res.data),
      error: err => reject(err)
    });
  });
}
function readFile(input){
  return new Promise((resolve, reject)=>{
    const file = input.files[0];
    if(!file) return resolve(null);
    const ext = file.name.toLowerCase().split('.').pop();
    const reader = new FileReader();
    if(ext === 'csv'){
      reader.onload = () => {
        const parsed = Papa.parse(reader.result, { header:true, skipEmptyLines:true });
        resolve(parsed.data);
      };
      reader.onerror = reject;
      reader.readAsText(file);
    } else {
      reader.onload = () => {
        const wb = XLSX.read(new Uint8Array(reader.result), {type:'array'});
        const first = wb.SheetNames[0];
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[first], {defval:""});
        resolve(rows);
      };
      reader.onerror = reject;
      reader.readAsArrayBuffer(file);
    }
  });
}
function coerceNumber(v){
  if (v === null || v === undefined) return 0;
  if (typeof v === 'number') return v;
  const n = parseFloat(String(v).replace(/[, ]/g,''));
  return isNaN(n) ? 0 : n;
}

function summarize(){
  // Snapshot
  const siteIdCols = ['Site ID','SiteID','Reference','Ref','Site Reference'];
  const dateCols = ['Date','Submission Date','Registered Date','Registration Date','Last Updated'];
  const unitCols = ['Total Units','Total Biodiversity Units','Net Units','Net Gain Units','Total BNG Units'];

  const siteCount = new Set(consolidated.map(r=>{
    for(const c of siteIdCols){ if(r[c]) return String(r[c]).trim(); }
    return JSON.stringify(r);
  })).size;

  // Try and find a date range
  let dates = [];
  consolidated.forEach(r=>{
    for(const c of dateCols){
      if(r[c]){
        const d = new Date(r[c]);
        if(!isNaN(d)) dates.push(d);
      }
    }
  });
  dates.sort((a,b)=>a-b);
  const fmt = d => d ? d.toISOString().slice(0,10) : 'n/a';

  // Totals (best-effort)
  let totalUnits = 0;
  consolidated.forEach(r=>{
    for(const c of unitCols){
      if(r[c]) { totalUnits += coerceNumber(r[c]); break; }
    }
  });

  snapEl.innerHTML = `
    <div><strong>Sites:</strong> ${siteCount}</div>
    <div><strong>Date range (from consolidated):</strong> ${fmt(dates[0])} â†’ ${fmt(dates[dates.length-1])}</div>
  `;
  totalsEl.innerHTML = `
    <div><strong>Estimated total units:</strong> ${totalUnits.toLocaleString()}</div>
  `;

  // Cross-check sites present in both
  const conKeys = new Set(consolidated.map(r=>{
    for(const c of siteIdCols){ if(r[c]) return String(r[c]).trim(); }
    return '';
  }).filter(Boolean));
  const longKeys = new Set(longrows.map(r=>{
    for(const c of siteIdCols){ if(r[c]) return String(r[c]).trim(); }
    return '';
  }).filter(Boolean));

  let inConNotLong = 0, inLongNotCon = 0;
  conKeys.forEach(k=>{ if(!longKeys.has(k)) inConNotLong++; });
  longKeys.forEach(k=>{ if(!conKeys.has(k)) inLongNotCon++; });

  const ok = inConNotLong===0 && inLongNotCon===0;
  crossEl.innerHTML = `
    <div class="${ok ? 'ok':'warn'}">
      ${ok ? 'Datasets appear consistent.' :
      `Potential mismatch: ${inConNotLong} site(s) only in consolidated; ${inLongNotCon} site(s) only in long.`}
    </div>
  `;
}

function drawHabitatChart(){
  // Guess habitat + units columns in long file
  const habitatCols = ['Habitat Type','Habitat','Type','BNG Habitat Type'];
  const unitCols = ['Units','Habitat Units','BNG Units','Biodiversity Units','Metric Units','Amount'];

  const pickCol = (row, candidates) => candidates.find(c => c in row);
  const hcol = longrows.length ? pickCol(longrows[0], habitatCols) : null;
  const ucol = longrows.length ? pickCol(longrows[0], unitCols) : null;

  const agg = new Map();
  longrows.forEach(r=>{
    const h = hcol ? String(r[hcol]).trim() : 'Unknown';
    const u = ucol ? coerceNumber(r[ucol]) : 0;
    agg.set(h, (agg.get(h)||0) + u);
  });

  const labels = [...agg.keys()];
  const data = labels.map(l=> agg.get(l));
  const ctx = document.getElementById('habitatChart');
  if (habitatChart) habitatChart.destroy();
  habitatChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [{ label: 'Units', data, backgroundColor: '#2a9d8f' }]
    },
    options: {
      indexAxis: labels.length > 8 ? 'y' : 'x',
      plugins: { legend: { display:false } },
      scales: { x: { ticks: { precision:0 } } }
    }
  });
}

function renderSites(){
  if (!consolidated.length){ sitesHead.innerHTML=''; sitesBody.innerHTML=''; return; }
  const columns = Object.keys(consolidated[0]).slice(0, 10); // keep to first 10 cols for simplicity
  sitesHead.innerHTML = columns.map(c=>`<th>${c}</th>`).join('');
  const q = siteFilter.value.toLowerCase();
  const filtered = q ? consolidated.filter(r=> Object.values(r).some(v=> String(v).toLowerCase().includes(q))) : consolidated;

  sitesBody.innerHTML = filtered.slice(0, 500).map(r=>{
    return `<tr>${columns.map(c=>`<td>${r[c] ?? ''}</td>`).join('')}</tr>`;
  }).join('');
}

async function loadFromURLs(){
  const cUrl = document.getElementById('conUrl').value.trim();
  const lUrl = document.getElementById('longUrl').value.trim();
  if(!cUrl || !lUrl){ alert('Please provide both URLs.'); return; }
  statusEl.textContent = 'Loading...';
  consolidated = await readCSVFromURL(cUrl);
  longrows = await readCSVFromURL(lUrl);
  statusEl.textContent = `Loaded ${consolidated.length} consolidated rows and ${longrows.length} long rows.`;
  summarize(); drawHabitatChart(); renderSites();
}

async function loadFromFiles(){
  statusEl.textContent = 'Reading files...';
  const con = await readFile(document.getElementById('conFile'));
  const lon = await readFile(document.getElementById('longFile'));
  if(!con || !lon){ alert('Please choose both files.'); return; }
  consolidated = con; longrows = lon;
  statusEl.textContent = `Loaded ${consolidated.length} consolidated rows and ${longrows.length} long rows.`;
  summarize(); drawHabitatChart(); renderSites();
}

document.getElementById('loadBtn').addEventListener('click', loadFromURLs);
document.getElementById('uploadBtn').addEventListener('click', loadFromFiles);
siteFilter.addEventListener('input', renderSites);
</script>
</body>
</html>
